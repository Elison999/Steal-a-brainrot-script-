-- Sistema Completo Rayfield com Funcionalidades Avan√ßadas
-- Carregamento da biblioteca Rayfield
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Servi√ßos
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

-- Vari√°veis globais
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local RootPart = Character:WaitForChild("HumanoidRootPart")

-- Fun√ß√£o para atualizar refer√™ncias do personagem
local function UpdateCharacterReferences()
    Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    if Character then
        Humanoid = Character:WaitForChild("Humanoid")
        RootPart = Character:WaitForChild("HumanoidRootPart")
    end
end

-- Fun√ß√£o para limpar sistemas ativos
local function CleanupActiveSystems()
    -- Parar flutua√ß√£o
    if FloatConnection then
        FloatConnection:Disconnect()
        FloatConnection = nil
    end
    
    -- Parar movimento da cadeira
    for i, connection in pairs(MovementConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    MovementConnections = {}
    
    -- Parar NoClip
    if NoClipConnection then
        NoClipConnection:Disconnect()
        NoClipConnection = nil
    end
    
    -- Remover objetos do workspace
    if ChairBlock then
        ChairBlock:Destroy()
        ChairBlock = nil
    end
    
    if NoClipBlock then
        NoClipBlock:Destroy()
        NoClipBlock = nil
    end
    
    if GlobalProtectionBlock then
        GlobalProtectionBlock:Destroy()
        GlobalProtectionBlock = nil
    end
    
    -- Limpar conex√µes globais
    if getgenv().NoClipConnections then
        for name, connection in pairs(getgenv().NoClipConnections) do
            if connection then
                connection:Disconnect()
            end
        end
        getgenv().NoClipConnections = nil
    end
    
    -- Reset de estados
    FloatEnabled = false
    ChairSystemEnabled = false
    NoClipEnabled = false
    ChairHeight = 0
end

-- Fun√ß√£o para reativar sistemas ap√≥s respawn
local function ReactivateSystemsAfterRespawn()
    wait(1) -- Aguardar estabiliza√ß√£o do personagem
    
    -- Reativar flutua√ß√£o se estava ativo
    if FloatButton and FloatButton.Parent then
        local currentText = FloatButton.TextButton.Text
        if currentText == "Desativar Float" then
            FloatEnabled = false
            ToggleFloat()
        end
    end
    
    -- Reativar cadeira se estava ativa
    if ChairButton and ChairButton.Parent then
        local currentText = ChairButton.TextButton.Text
        if currentText == "Desativar Cadeira" then
            ChairSystemEnabled = false
            ToggleChairSystem()
        end
    end
    
    -- Reativar NoClip se estava ativo
    if NoClipEnabled then
        NoClipEnabled = false
        ToggleNoClip()
    end
end

-- Event para reconectar quando o personagem spawnar
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    -- Limpar sistemas ativos do personagem anterior
    CleanupActiveSystems()
    
    -- Aguardar carregamento completo do novo personagem
    newCharacter:WaitForChild("Humanoid")
    newCharacter:WaitForChild("HumanoidRootPart")
    
    -- Atualizar refer√™ncias
    UpdateCharacterReferences()
    
    -- Notificar respawn
    game.StarterGui:SetCore("SendNotification", {
        Title = "Personagem Respawnado";
        Text = "Sistemas sendo reconectados...";
        Duration = 3;
    })
    
    -- Reativar sistemas ap√≥s um delay
    spawn(ReactivateSystemsAfterRespawn)
end)

-- Event para detectar morte e limpar sistemas
if Humanoid then
    Humanoid.Died:Connect(function()
        game.StarterGui:SetCore("SendNotification", {
            Title = "Morte Detectada";
            Text = "Limpando sistemas ativos...";
            Duration = 2;
        })
        CleanupActiveSystems()
    end)
end

-- Estados dos sistemas
local FloatEnabled = false
local ChairSystemEnabled = false
local PositionSystemEnabled = false
local NoClipEnabled = false
local SavedPosition = nil

-- Conex√µes ativas
local FloatConnection = nil
local ChairConnection = nil
local TeleportConnection = nil
local NoClipConnection = nil

-- Objetos da interface
local FloatButton = nil
local ChairButton = nil
local SaveButton = nil
local TeleportButton = nil
local ChairBlock = nil
local ChairControlsFrame = nil
local NoClipBlock = nil
local GlobalProtectionBlock = nil

-- Vari√°veis para controle de movimento cont√≠nuo
local MovementConnections = {}
local ChairHeight = 0
local LastTeleportTime = 0
local LastSafePosition = nil
local VelocityHistory = {}
local FloorDetectionHistory = {}
local EmergencyMode = false

-- Fun√ß√£o para criar barra de carregamento
local function ShowLoadingBar()
    local ScreenGui = Instance.new("ScreenGui")
    local Frame = Instance.new("Frame")
    local LoadingBar = Instance.new("Frame")
    local Fill = Instance.new("Frame")
    local LoadingText = Instance.new("TextLabel")
    local Corner = Instance.new("UICorner")
    local BarCorner = Instance.new("UICorner")
    local FillCorner = Instance.new("UICorner")
    
    ScreenGui.Name = "LoadingScreen"
    ScreenGui.Parent = game.CoreGui
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    Frame.Parent = ScreenGui
    Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Frame.BackgroundTransparency = 0.1
    Frame.Position = UDim2.new(0, 0, 0, 0)
    Frame.Size = UDim2.new(1, 0, 1, 0)
    
    Corner.CornerRadius = UDim.new(0, 12)
    Corner.Parent = Frame
    
    LoadingBar.Name = "LoadingBar"
    LoadingBar.Parent = Frame
    LoadingBar.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    LoadingBar.Position = UDim2.new(0.5, -200, 0.5, -15)
    LoadingBar.Size = UDim2.new(0, 400, 0, 30)
    
    BarCorner.CornerRadius = UDim.new(0, 8)
    BarCorner.Parent = LoadingBar
    
    Fill.Name = "Fill"
    Fill.Parent = LoadingBar
    Fill.BackgroundColor3 = Color3.fromRGB(100, 200, 255)
    Fill.Size = UDim2.new(0, 0, 1, 0)
    
    FillCorner.CornerRadius = UDim.new(0, 8)
    FillCorner.Parent = Fill
    
    LoadingText.Parent = Frame
    LoadingText.BackgroundTransparency = 1
    LoadingText.Position = UDim2.new(0.5, -100, 0.5, -50)
    LoadingText.Size = UDim2.new(0, 200, 0, 30)
    LoadingText.Font = Enum.Font.GothamBold
    LoadingText.Text = "Carregando Sistema..."
    LoadingText.TextColor3 = Color3.fromRGB(255, 255, 255)
    LoadingText.TextScaled = true
    
    -- Anima√ß√£o da barra
    local tween = TweenService:Create(Fill, TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1, 0, 1, 0)})
    tween:Play()
    
    tween.Completed:Connect(function()
        LoadingText.Text = "Sistema Carregado!"
        wait(0.5)
        ScreenGui:Destroy()
    end)
    
    wait(2.5)
end

-- Fun√ß√£o para criar bot√£o flutuante arrast√°vel
local function CreateDraggableButton(text, color, position, callback)
    local ScreenGui = Instance.new("ScreenGui")
    local Button = Instance.new("TextButton")
    local Corner = Instance.new("UICorner")
    
    ScreenGui.Name = text .. "Gui"
    ScreenGui.Parent = game.CoreGui
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    Button.Parent = ScreenGui
    Button.BackgroundColor3 = color
    Button.Position = position
    Button.Size = UDim2.new(0, 120, 0, 40)
    Button.Font = Enum.Font.GothamBold
    Button.Text = text
    Button.TextColor3 = Color3.fromRGB(255, 255, 255)
    Button.TextScaled = true
    Button.Active = true
    Button.Draggable = true
    
    Corner.CornerRadius = UDim.new(0, 8)
    Corner.Parent = Button
    
    -- Efeito de hover
    Button.MouseEnter:Connect(function()
        TweenService:Create(Button, TweenInfo.new(0.2), {Size = UDim2.new(0, 130, 0, 45)}):Play()
    end)
    
    Button.MouseLeave:Connect(function()
        TweenService:Create(Button, TweenInfo.new(0.2), {Size = UDim2.new(0, 120, 0, 40)}):Play()
    end)
    
    Button.MouseButton1Click:Connect(callback)
    
    return ScreenGui
end

-- Sistema de flutua√ß√£o
local function ToggleFloat()
    if not Character or not RootPart then 
        UpdateCharacterReferences()
        if not Character or not RootPart then return end
    end
    
    if FloatEnabled then
        FloatEnabled = false
        if FloatConnection then
            FloatConnection:Disconnect()
            FloatConnection = nil
        end
        if RootPart and RootPart:FindFirstChild("BodyVelocity") then
            RootPart.BodyVelocity:Destroy()
        end
        if FloatButton then
            FloatButton.TextButton.Text = "Ativar Float"
            FloatButton.TextButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
        end
    else
        FloatEnabled = true
        local BodyVelocity = Instance.new("BodyVelocity")
        BodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000)
        BodyVelocity.Velocity = Vector3.new(0, 16.2, 0)
        BodyVelocity.Parent = RootPart
        
        if FloatButton then
            FloatButton.TextButton.Text = "Desativar Float"
            FloatButton.TextButton.BackgroundColor3 = Color3.fromRGB(100, 200, 100)
        end
        
        FloatConnection = RunService.Heartbeat:Connect(function()
            if not FloatEnabled or not Character or not RootPart or not Humanoid then return end
            
            local moveVector = Humanoid.MoveDirection
            if BodyVelocity and BodyVelocity.Parent then
                if moveVector.Magnitude > 0 then
                    BodyVelocity.Velocity = Vector3.new(moveVector.X * 16, 16.2, moveVector.Z * 16)
                else
                    BodyVelocity.Velocity = Vector3.new(0, 16.2, 0)
                end
            end
        end)
    end
end

-- Vari√°veis para controle de movimento cont√≠nuo
local MovementConnections = {}
local ChairHeight = 0

-- Sistema de cadeira m√≥vel
local function CreateChairControls()
    local ScreenGui = Instance.new("ScreenGui")
    local Frame = Instance.new("Frame")
    local Corner = Instance.new("UICorner")
    
    ScreenGui.Name = "ChairControls"
    ScreenGui.Parent = game.CoreGui
    
    Frame.Parent = ScreenGui
    Frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    Frame.BackgroundTransparency = 0.2
    Frame.Position = UDim2.new(0.5, -90, 0.8, -75)
    Frame.Size = UDim2.new(0, 180, 0, 150)
    Frame.Active = true
    Frame.Draggable = true
    
    Corner.CornerRadius = UDim.new(0, 12)
    Corner.Parent = Frame
    
    -- T√≠tulo do controle
    local Title = Instance.new("TextLabel")
    Title.Parent = Frame
    Title.BackgroundTransparency = 1
    Title.Position = UDim2.new(0, 0, 0, 5)
    Title.Size = UDim2.new(1, 0, 0, 25)
    Title.Font = Enum.Font.GothamBold
    Title.Text = "Controles da Cadeira"
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.TextScaled = true
    
    local buttons = {
        {text = "‚Üë", pos = UDim2.new(0.5, -20, 0, 35), dir = Vector3.new(0, 0, -1)},
        {text = "‚Üê", pos = UDim2.new(0, 10, 0.5, -15), dir = Vector3.new(-1, 0, 0)},
        {text = "‚Üí", pos = UDim2.new(1, -50, 0.5, -15), dir = Vector3.new(1, 0, 0)},
        {text = "‚Üì", pos = UDim2.new(0.5, -20, 1, -75), dir = Vector3.new(0, 0, 1)}
    }
    
    -- Fun√ß√£o para parar movimento
    local function StopMovement(buttonId)
        if MovementConnections[buttonId] then
            MovementConnections[buttonId]:Disconnect()
            MovementConnections[buttonId] = nil
        end
    end
    
    -- Fun√ß√£o para iniciar movimento cont√≠nuo
    local function StartMovement(direction, buttonId)
        StopMovement(buttonId) -- Para qualquer movimento anterior
        
        MovementConnections[buttonId] = RunService.Heartbeat:Connect(function()
            if ChairBlock then
                local newPosition = ChairBlock.Position + (direction * 0.5) -- Movimento mais suave
                ChairBlock.Position = newPosition
                
                -- Atualizar posi√ß√£o do assento tamb√©m
                local seat = ChairBlock:FindFirstChild("Seat")
                if seat then
                    seat.Position = newPosition + Vector3.new(0, 0.75 + ChairHeight, 0)
                end
                
                -- Manter jogador na cadeira
                if Humanoid.Sit then
                    RootPart.CFrame = CFrame.new(newPosition + Vector3.new(0, 2 + ChairHeight, 0))
                end
            end
        end)
    end
    
    for i, buttonData in pairs(buttons) do
        local Button = Instance.new("TextButton")
        local ButtonCorner = Instance.new("UICorner")
        
        Button.Parent = Frame
        Button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        Button.Position = buttonData.pos
        Button.Size = UDim2.new(0, 40, 0, 30)
        Button.Font = Enum.Font.GothamBold
        Button.Text = buttonData.text
        Button.TextColor3 = Color3.fromRGB(255, 255, 255)
        Button.TextScaled = true
        
        ButtonCorner.CornerRadius = UDim.new(0, 6)
        ButtonCorner.Parent = Button
        
        -- Evento de pressionar (segurar)
        Button.MouseButton1Down:Connect(function()
            Button.BackgroundColor3 = Color3.fromRGB(100, 150, 100)
            StartMovement(buttonData.dir, i)
        end)
        
        -- Evento de soltar
        Button.MouseButton1Up:Connect(function()
            Button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
            StopMovement(i)
        end)
        
        -- Hover effects
        Button.MouseEnter:Connect(function()
            if not MovementConnections[i] then
                Button.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
            end
        end)
        
        Button.MouseLeave:Connect(function()
            if not MovementConnections[i] then
                Button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
            end
            StopMovement(i) -- Para o movimento se sair do bot√£o
        end)
    end
    
    -- Bot√µes de altura
    local UpButton = Instance.new("TextButton")
    local UpCorner = Instance.new("UICorner")
    local DownButton = Instance.new("TextButton")
    local DownCorner = Instance.new("UICorner")
    local HeightLabel = Instance.new("TextLabel")
    
    -- Bot√£o para subir
    UpButton.Parent = Frame
    UpButton.BackgroundColor3 = Color3.fromRGB(100, 200, 100)
    UpButton.Position = UDim2.new(0, 10, 1, -40)
    UpButton.Size = UDim2.new(0, 35, 0, 30)
    UpButton.Font = Enum.Font.GothamBold
    UpButton.Text = "‚ñ≤"
    UpButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    UpButton.TextScaled = true
    
    UpCorner.CornerRadius = UDim.new(0, 6)
    UpCorner.Parent = UpButton
    
    -- Bot√£o para descer
    DownButton.Parent = Frame
    DownButton.BackgroundColor3 = Color3.fromRGB(200, 100, 100)
    DownButton.Position = UDim2.new(1, -45, 1, -40)
    DownButton.Size = UDim2.new(0, 35, 0, 30)
    DownButton.Font = Enum.Font.GothamBold
    DownButton.Text = "‚ñº"
    DownButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    DownButton.TextScaled = true
    
    DownCorner.CornerRadius = UDim.new(0, 6)
    DownCorner.Parent = DownButton
    
    -- Label de altura
    HeightLabel.Parent = Frame
    HeightLabel.BackgroundTransparency = 1
    HeightLabel.Position = UDim2.new(0, 50, 1, -40)
    HeightLabel.Size = UDim2.new(0, 80, 0, 30)
    HeightLabel.Font = Enum.Font.Gotham
    HeightLabel.Text = "Altura: 0"
    HeightLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    HeightLabel.TextScaled = true
    
    -- Fun√ß√£o para atualizar altura
    local function UpdateHeight(increment)
        ChairHeight = ChairHeight + increment
        ChairHeight = math.max(-2, math.min(10, ChairHeight)) -- Limitar entre -2 e 10
        
        HeightLabel.Text = "Altura: " .. math.floor(ChairHeight * 10) / 10
        
        if ChairBlock then
            local seat = ChairBlock:FindFirstChild("Seat")
            if seat then
                seat.Position = ChairBlock.Position + Vector3.new(0, 0.75 + ChairHeight, 0)
            end
            
            -- Atualizar posi√ß√£o do jogador se estiver sentado
            if Humanoid.Sit then
                RootPart.CFrame = CFrame.new(ChairBlock.Position + Vector3.new(0, 2 + ChairHeight, 0))
            end
        end
    end
    
    -- Eventos dos bot√µes de altura (tamb√©m segur√°veis)
    local heightUpConnection = nil
    local heightDownConnection = nil
    
    -- Subir altura
    UpButton.MouseButton1Down:Connect(function()
        UpButton.BackgroundColor3 = Color3.fromRGB(120, 220, 120)
        UpdateHeight(0.1)
        
        heightUpConnection = RunService.Heartbeat:Connect(function()
            UpdateHeight(0.05) -- Movimento cont√≠nuo mais lento
        end)
    end)
    
    UpButton.MouseButton1Up:Connect(function()
        UpButton.BackgroundColor3 = Color3.fromRGB(100, 200, 100)
        if heightUpConnection then
            heightUpConnection:Disconnect()
            heightUpConnection = nil
        end
    end)
    
    UpButton.MouseLeave:Connect(function()
        UpButton.BackgroundColor3 = Color3.fromRGB(100, 200, 100)
        if heightUpConnection then
            heightUpConnection:Disconnect()
            heightUpConnection = nil
        end
    end)
    
    -- Descer altura
    DownButton.MouseButton1Down:Connect(function()
        DownButton.BackgroundColor3 = Color3.fromRGB(220, 120, 120)
        UpdateHeight(-0.1)
        
        heightDownConnection = RunService.Heartbeat:Connect(function()
            UpdateHeight(-0.05) -- Movimento cont√≠nuo mais lento
        end)
    end)
    
    DownButton.MouseButton1Up:Connect(function()
        DownButton.BackgroundColor3 = Color3.fromRGB(200, 100, 100)
        if heightDownConnection then
            heightDownConnection:Disconnect()
            heightDownConnection = nil
        end
    end)
    
    DownButton.MouseLeave:Connect(function()
        DownButton.BackgroundColor3 = Color3.fromRGB(200, 100, 100)
        if heightDownConnection then
            heightDownConnection:Disconnect()
            heightDownConnection = nil
        end
    end)
    
    return ScreenGui
end

local function ToggleChairSystem()
    if not Character or not RootPart then 
        UpdateCharacterReferences()
        if not Character or not RootPart then return end
    end
    
    if ChairSystemEnabled then
        ChairSystemEnabled = false
        
        -- Parar todas as conex√µes de movimento
        for i, connection in pairs(MovementConnections) do
            if connection then
                connection:Disconnect()
            end
        end
        MovementConnections = {}
        ChairHeight = 0
        
        -- Remover cadeira e controles
        if ChairBlock then
            ChairBlock:Destroy()
            ChairBlock = nil
        end
        if ChairControlsFrame then
            ChairControlsFrame:Destroy()
            ChairControlsFrame = nil
        end
        if ChairButton then
            ChairButton.TextButton.Text = "Ativar Cadeira"
            ChairButton.TextButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
        end
    else
        ChairSystemEnabled = true
        ChairHeight = 0 -- Reset da altura
        
        -- Criar bloco da cadeira
        ChairBlock = Instance.new("Part")
        ChairBlock.Name = "ChairBlock"
        ChairBlock.Parent = workspace
        ChairBlock.Size = Vector3.new(4, 1, 4)
        ChairBlock.Material = Enum.Material.Neon
        ChairBlock.BrickColor = BrickColor.new("Bright blue")
        ChairBlock.Anchored = true
        ChairBlock.CanCollide = true
        ChairBlock.Position = RootPart.Position - Vector3.new(0, 3, 0)
        
        -- Sentar no bloco
        local Seat = Instance.new("Seat")
        Seat.Name = "Seat"
        Seat.Parent = ChairBlock
        Seat.Size = Vector3.new(4, 0.5, 4)
        Seat.Position = ChairBlock.Position + Vector3.new(0, 0.75, 0)
        Seat.Material = Enum.Material.Fabric
        Seat.BrickColor = BrickColor.new("Really red")
        Seat.Anchored = true
        
        -- Criar controles
        ChairControlsFrame = CreateChairControls()
        
        if ChairButton then
            ChairButton.TextButton.Text = "Desativar Cadeira"
            ChairButton.TextButton.BackgroundColor3 = Color3.fromRGB(200, 100, 100)
        end
        
        -- Sentar automaticamente
        wait(0.1)
        if Humanoid then
            Humanoid.Sit = true
            RootPart.CFrame = CFrame.new(ChairBlock.Position + Vector3.new(0, 2, 0))
        end
    end
end

-- Sistema NoClip com prote√ß√£o de ch√£o
local function ToggleNoClip()
    if not Character or not RootPart then 
        UpdateCharacterReferences()
        if not Character or not RootPart then return end
    end
    
    if NoClipEnabled then
        NoClipEnabled = false
        
        -- Restaurar colis√£o das partes do personagem
        if Character then
            for _, part in pairs(Character:GetChildren()) do
                if part:IsA("BasePart") and part ~= RootPart then
                    part.CanCollide = true
                end
            end
        end
        
        -- Remover bloco protetor e conex√£o
        if NoClipBlock then
            NoClipBlock:Destroy()
            NoClipBlock = nil
        end
        
        -- Remover bloco de prote√ß√£o global
        if GlobalProtectionBlock then
            GlobalProtectionBlock:Destroy()
            GlobalProtectionBlock = nil
        end
        
        if NoClipConnection then
            NoClipConnection:Disconnect()
            NoClipConnection = nil
        end
        
        game.StarterGui:SetCore("SendNotification", {
            Title = "NoClip Desativado";
            Text = "Colis√£o restaurada normalmente.";
            Duration = 3;
        })
    else
        NoClipEnabled = true
        
        -- Criar bloco de prote√ß√£o global gigante e invis√≠vel
        GlobalProtectionBlock = Instance.new("Part")
        GlobalProtectionBlock.Name = "GlobalFloorProtection"
        GlobalProtectionBlock.Parent = workspace
        GlobalProtectionBlock.Size = Vector3.new(10000, 50, 10000) -- Bloco gigante
        GlobalProtectionBlock.Material = Enum.Material.ForceField
        GlobalProtectionBlock.BrickColor = BrickColor.new("Bright red")
        GlobalProtectionBlock.Transparency = 1 -- Completamente invis√≠vel
        GlobalProtectionBlock.Anchored = true
        GlobalProtectionBlock.CanCollide = false -- N√£o bloqueia movimento normal
        GlobalProtectionBlock.Position = Vector3.new(0, -1000, 0) -- Bem abaixo do mapa
        
        -- Criar bloco protetor visual que segue o jogador
        NoClipBlock = Instance.new("Part")
        NoClipBlock.Name = "NoClipFloorProtection"
        NoClipBlock.Parent = workspace
        NoClipBlock.Size = Vector3.new(4, 0.5, 4)
        NoClipBlock.Material = Enum.Material.ForceField
        NoClipBlock.BrickColor = BrickColor.new("Bright green")
        NoClipBlock.Transparency = 0.7
        NoClipBlock.Anchored = true
        NoClipBlock.CanCollide = true
        NoClipBlock.Position = RootPart.Position - Vector3.new(0, 4, 0)
        
        -- Adicionar efeito visual ao bloco protetor
        local SelectionBox = Instance.new("SelectionBox")
        SelectionBox.Parent = NoClipBlock
        SelectionBox.Adornee = NoClipBlock
        SelectionBox.Color3 = Color3.fromRGB(0, 255, 0)
        SelectionBox.LineThickness = 0.2
        SelectionBox.Transparency = 0.3
        
        -- Sistema de detec√ß√£o por toque no bloco global
        local teleportConnection = nil
        teleportConnection = GlobalProtectionBlock.Touched:Connect(function(hit)
            if hit.Parent == Character and hit == RootPart then
                local currentTime = tick()
                
                -- Cooldown para evitar teleportes m√∫ltiplos
                if currentTime - LastTeleportTime > 1 then
                    LastTeleportTime = currentTime
                    
                    -- Encontrar posi√ß√£o segura para teleporte
                    local playerPos = RootPart.Position
                    local safePosY = -950 -- Posi√ß√£o segura acima do bloco global
                    
                    -- Tentar detectar ch√£o real pr√≥ximo
                    local raycast = workspace:Raycast(Vector3.new(playerPos.X, 0, playerPos.Z), Vector3.new(0, -500, 0))
                    if raycast then
                        safePosY = raycast.Position.Y + 10
                    end
                    
                    -- Teleportar para posi√ß√£o segura
                    RootPart.CFrame = CFrame.new(playerPos.X, safePosY, playerPos.Z)
                    
                    -- Efeito visual dram√°tico
                    if NoClipBlock then
                        NoClipBlock.BrickColor = BrickColor.new("Bright yellow")
                        NoClipBlock.Transparency = 0.1
                        NoClipBlock.Material = Enum.Material.Neon
                        NoClipBlock.Size = Vector3.new(10, 2, 10)
                    end
                    
                    -- Efeitos de part√≠cula
                    spawn(function()
                        for i = 1, 5 do
                            local effect = Instance.new("Explosion")
                            effect.Parent = workspace
                            effect.Position = Vector3.new(playerPos.X + math.random(-3, 3), safePosY, playerPos.Z + math.random(-3, 3))
                            effect.BlastRadius = 0
                            effect.BlastPressure = 0
                            effect.Visible = false -- S√≥ o som
                            wait(0.05)
                        end
                    end)
                    
                    game.StarterGui:SetCore("SendNotification", {
                        Title = "üö® PROTE√á√ÉO GLOBAL ATIVADA!";
                        Text = "Travessia de ch√£o detectada! Teleportado para seguran√ßa.";
                        Duration = 4;
                    })
                    
                    -- Restaurar visual do bloco ap√≥s delay
                    spawn(function()
                        wait(1)
                        if NoClipBlock then
                            NoClipBlock.Material = Enum.Material.ForceField
                            NoClipBlock.Size = Vector3.new(4, 0.5, 4)
                        end
                    end)
                end
            end
        end)
        
        -- Armazenar conex√£o para limpeza posterior
        if not getgenv().NoClipConnections then
            getgenv().NoClipConnections = {}
        end
        getgenv().NoClipConnections.TouchConnection = teleportConnection
        
        NoClipConnection = RunService.Heartbeat:Connect(function()
            if not NoClipEnabled or not Character or not RootPart then return end
            
            -- Desativar colis√£o de todas as partes exceto o HumanoidRootPart
            for _, part in pairs(Character:GetChildren()) do
                if part:IsA("BasePart") and part ~= RootPart then
                    part.CanCollide = false
                end
            end
            
            -- Manter RootPart sem colis√£o tamb√©m (para atravessar paredes)
            RootPart.CanCollide = false
            
            local playerPos = RootPart.Position
            local currentTime = tick()
            
            -- Sistema de detec√ß√£o de ch√£o
            local function DetectFloor()
                local raycast = workspace:Raycast(playerPos, Vector3.new(0, -30, 0))
                if raycast then
                    return raycast.Position.Y
                end
                return playerPos.Y - 50
            end
            
            -- Detectar ch√£o
            local groundY = DetectFloor()
            
            -- Hist√≥rico de velocidade para efeitos visuais
            table.insert(VelocityHistory, {
                position = playerPos,
                time = currentTime,
                velocity = RootPart.Velocity
            })
            
            -- Manter apenas √∫ltimos 10 frames
            if #VelocityHistory > 10 then
                table.remove(VelocityHistory, 1)
            end
            
            -- Calcular velocidade vertical m√©dia
            local avgVerticalVelocity = 0
            if #VelocityHistory >= 2 then
                for i = 2, #VelocityHistory do
                    avgVerticalVelocity = avgVerticalVelocity + VelocityHistory[i].velocity.Y
                end
                avgVerticalVelocity = avgVerticalVelocity / (#VelocityHistory - 1)
            end
            
            -- Atualizar posi√ß√£o do bloco protetor
            if NoClipBlock then
                local optimalY = math.max(groundY + 1, playerPos.Y - 8)
                NoClipBlock.Position = Vector3.new(playerPos.X, optimalY, playerPos.Z)
                
                local distanceToGround = playerPos.Y - groundY
                local distanceToBlock = math.abs(playerPos.Y - NoClipBlock.Position.Y)
                
                -- Sistema visual baseado em risco (sem teleporte)
                local riskLevel = 0
                
                if distanceToGround < 10 then riskLevel = riskLevel + 0.3 end
                if avgVerticalVelocity < -50 then riskLevel = riskLevel + 0.4 end
                if distanceToBlock < 3 then riskLevel = riskLevel + 0.3 end
                
                -- Cores baseadas no n√≠vel de risco
                if riskLevel > 0.7 then
                    -- Risco alto: Vermelho piscante
                    local pulse = math.sin(currentTime * 10) * 0.3 + 0.7
                    NoClipBlock.BrickColor = BrickColor.new("Bright red")
                    NoClipBlock.Transparency = pulse
                    NoClipBlock.Size = Vector3.new(5 + pulse, 0.5, 5 + pulse)
                elseif riskLevel > 0.4 then
                    -- Risco m√©dio: Laranja
                    NoClipBlock.BrickColor = BrickColor.new("Neon orange")
                    NoClipBlock.Transparency = 0.4
                    NoClipBlock.Size = Vector3.new(4.5, 0.5, 4.5)
                elseif riskLevel > 0.1 then
                    -- Risco baixo: Amarelo
                    NoClipBlock.BrickColor = BrickColor.new("Bright yellow")
                    NoClipBlock.Transparency = 0.6
                    NoClipBlock.Size = Vector3.new(4.2, 0.5, 4.2)
                else
                    -- Seguro: Verde
                    NoClipBlock.BrickColor = BrickColor.new("Bright green")
                    NoClipBlock.Transparency = 0.7
                    NoClipBlock.Size = Vector3.new(4, 0.5, 4)
                end
            end
        end)
            RootPart.CanCollide = false
            
            local playerPos = RootPart.Position
            local currentTime = tick()
            
            -- Sistema inteligente de detec√ß√£o de ch√£o
            local function PerformIntelligentFloorDetection()
                local detectionResults = {}
                
                -- M√∫ltiplos raycasts em diferentes dire√ß√µes para m√°xima precis√£o
                local rayDirections = {
                    Vector3.new(0, -30, 0),      -- Direto para baixo
                    Vector3.new(2, -30, 0),      -- Diagonal frente-direita
                    Vector3.new(-2, -30, 0),     -- Diagonal frente-esquerda
                    Vector3.new(0, -30, 2),      -- Diagonal tr√°s-direita
                    Vector3.new(0, -30, -2),     -- Diagonal tr√°s-esquerda
                }
                
                for i, direction in ipairs(rayDirections) do
                    local raycast = workspace:Raycast(playerPos, direction)
                    if raycast then
                        table.insert(detectionResults, {
                            position = raycast.Position,
                            distance = (playerPos - raycast.Position).Magnitude,
                            normal = raycast.Normal,
                            material = raycast.Material
                        })
                    end
                end
                
                -- Encontrar o ch√£o mais pr√≥ximo e confi√°vel
                if #detectionResults > 0 then
                    table.sort(detectionResults, function(a, b) return a.distance < b.distance end)
                    return detectionResults[1]
                end
                
                return nil
            end
            
            -- Detectar ch√£o inteligente
            local floorData = PerformIntelligentFloorDetection()
            local groundY = floorData and floorData.position.Y or (playerPos.Y - 50)
            
            -- Hist√≥rico de velocidade para detectar queda r√°pida
            table.insert(VelocityHistory, {
                position = playerPos,
                time = currentTime,
                velocity = RootPart.Velocity
            })
            
            -- Manter apenas √∫ltimos 10 frames
            if #VelocityHistory > 10 then
                table.remove(VelocityHistory, 1)
            end
            
            -- Calcular velocidade vertical m√©dia
            local avgVerticalVelocity = 0
            if #VelocityHistory >= 2 then
                for i = 2, #VelocityHistory do
                    avgVerticalVelocity = avgVerticalVelocity + VelocityHistory[i].velocity.Y
                end
                avgVerticalVelocity = avgVerticalVelocity / (#VelocityHistory - 1)
            end
            
            -- Detectar posi√ß√£o segura
            if floorData and (playerPos.Y - groundY) > 5 and (playerPos.Y - groundY) < 100 then
                LastSafePosition = playerPos
            end
            
            -- Atualizar posi√ß√£o do bloco protetor
            if NoClipBlock then
                local optimalY = math.max(groundY + 1, playerPos.Y - 8)
                NoClipBlock.Position = Vector3.new(playerPos.X, optimalY, playerPos.Z)
                
                local distanceToGround = playerPos.Y - groundY
                local distanceToBlock = math.abs(playerPos.Y - NoClipBlock.Position.Y)
                
                -- Sistema de detec√ß√£o inteligente de travessia
                local shouldTeleport = false
                local teleportReason = ""
                
                -- Crit√©rio 1: Atravessou fisicamente o ch√£o
                if playerPos.Y <= groundY + 0.5 then
                    shouldTeleport = true
                    teleportReason = "Atravessou o ch√£o fisicamente"
                end
                
                -- Crit√©rio 2: Velocidade descendente muito alta
                if avgVerticalVelocity < -100 and distanceToGround < 15 then
                    shouldTeleport = true
                    teleportReason = "Queda muito r√°pida detectada"
                    EmergencyMode = true
                end
                
                -- Crit√©rio 3: Posi√ß√£o an√¥mala (muito abaixo do esperado)
                if distanceToGround > 200 and not floorData then
                    shouldTeleport = true
                    teleportReason = "Posi√ß√£o an√¥mala - poss√≠vel void"
                    EmergencyMode = true
                end
                
                -- Crit√©rio 4: Padr√£o de movimento suspeito (oscila√ß√£o atrav√©s do ch√£o)
                if #VelocityHistory >= 5 then
                    local oscillationCount = 0
                    for i = 2, #VelocityHistory do
                        if VelocityHistory[i].position.Y < groundY + 2 then
                            oscillationCount = oscillationCount + 1
                        end
                    end
                    if oscillationCount >= 3 then
                        shouldTeleport = true
                        teleportReason = "Padr√£o de oscila√ß√£o atrav√©s do ch√£o"
                    end
                end
                
                -- Executar teleporte inteligente
                if shouldTeleport and (currentTime - LastTeleportTime) > 0.3 then
                    LastTeleportTime = currentTime
                    
                    -- Determinar melhor posi√ß√£o de teleporte
                    local safePosY
                    if EmergencyMode and LastSafePosition then
                        -- Modo emerg√™ncia: voltar para √∫ltima posi√ß√£o segura
                        RootPart.CFrame = CFrame.new(LastSafePosition)
                        safePosY = LastSafePosition.Y
                        EmergencyMode = false
                    elseif floorData then
                        -- Modo normal: teleportar para cima do ch√£o detectado
                        safePosY = floorData.position.Y + 8
                        RootPart.CFrame = CFrame.new(playerPos.X, safePosY, playerPos.Z)
                    else
                        -- Fallback: subir 15 unidades
                        safePosY = playerPos.Y + 15
                        RootPart.CFrame = CFrame.new(playerPos.X, safePosY, playerPos.Z)
                    end
                    
                    -- Limpar hist√≥rico de velocidade ap√≥s teleporte
                    VelocityHistory = {}
                    
                    -- Feedback visual super intenso
                    NoClipBlock.BrickColor = BrickColor.new("Bright yellow")
                    NoClipBlock.Transparency = 0.1
                    NoClipBlock.Material = Enum.Material.Neon
                    NoClipBlock.Size = Vector3.new(8, 1, 8) -- Aumentar dramaticamente
                    
                    -- Efeito de part√≠culas melhorado
                    spawn(function()
                        for i = 1, 3 do
                            local effect = Instance.new("Explosion")
                            effect.Parent = workspace
                            effect.Position = Vector3.new(playerPos.X + math.random(-2, 2), safePosY, playerPos.Z + math.random(-2, 2))
                            effect.BlastRadius = 0
                            effect.BlastPressure = 0
                            effect.Visible = false
                            wait(0.1)
                        end
                    end)
                    
                    game.StarterGui:SetCore("SendNotification", {
                        Title = "üõ°Ô∏è PROTE√á√ÉO INTELIGENTE!";
                        Text = teleportReason;
                        Duration = 3;
                    })
                    
                    -- Restaurar visual do bloco
                    spawn(function()
                        wait(0.5)
                        if NoClipBlock then
                            NoClipBlock.Material = Enum.Material.ForceField
                            NoClipBlock.Size = Vector3.new(4, 0.5, 4)
                        end
                    end)
                end
                
                -- Sistema visual avan√ßado baseado em risco
                local riskLevel = 0
                
                if distanceToGround < 10 then riskLevel = riskLevel + 0.3 end
                if avgVerticalVelocity < -50 then riskLevel = riskLevel + 0.4 end
                if distanceToBlock < 3 then riskLevel = riskLevel + 0.3 end
                
                -- Cores baseadas no n√≠vel de risco
                if riskLevel > 0.7 then
                    -- Risco alto: Vermelho piscante
                    local pulse = math.sin(currentTime * 10) * 0.3 + 0.7
                    NoClipBlock.BrickColor = BrickColor.new("Bright red")
                    NoClipBlock.Transparency = pulse
                    NoClipBlock.Size = Vector3.new(5 + pulse, 0.5, 5 + pulse)
                elseif riskLevel > 0.4 then
                    -- Risco m√©dio: Laranja
                    NoClipBlock.BrickColor = BrickColor.new("Neon orange")
                    NoClipBlock.Transparency = 0.4
                    NoClipBlock.Size = Vector3.new(4.5, 0.5, 4.5)
                elseif riskLevel > 0.1 then
                    -- Risco baixo: Amarelo
                    NoClipBlock.BrickColor = BrickColor.new("Bright yellow")
                    NoClipBlock.Transparency = 0.6
                    NoClipBlock.Size = Vector3.new(4.2, 0.5, 4.2)
                else
                    -- Seguro: Verde
                    NoClipBlock.BrickColor = BrickColor.new("Bright green")
                    NoClipBlock.Transparency = 0.7
                    NoClipBlock.Size = Vector3.new(4, 0.5, 4)
                end
            end
        end)
        
        game.StarterGui:SetCore("SendNotification", {
            Title = "NoClip Ativado!";
            Text = "Atravesse paredes! Prote√ß√£o global anti-queda ativada.";
            Duration = 4;
        })
    end
end
-- Sistema de salvamento de posi√ß√£o
local function SavePosition()
    if not RootPart then 
        UpdateCharacterReferences()
        if not RootPart then return end
    end
    
    SavedPosition = RootPart.Position
    game.StarterGui:SetCore("SendNotification", {
        Title = "Posi√ß√£o Salva!";
        Text = "Posi√ß√£o atual foi salva com sucesso.";
        Duration = 3;
    })
end

local function TeleportToSavedPosition()
    if not RootPart then 
        UpdateCharacterReferences()
        if not RootPart then return end
    end
    
    if SavedPosition then
        local targetCFrame = CFrame.new(SavedPosition)
        
        -- Anima√ß√£o de teleporte suave
        local startPos = RootPart.Position
        local distance = (SavedPosition - startPos).Magnitude
        local duration = math.min(distance / 50, 3) -- M√°ximo 3 segundos
        
        local bodyPosition = Instance.new("BodyPosition")
        bodyPosition.MaxForce = Vector3.new(4000, 4000, 4000)
        bodyPosition.Position = SavedPosition
        bodyPosition.Parent = RootPart
        
        wait(duration)
        if bodyPosition and bodyPosition.Parent then
            bodyPosition:Destroy()
        end
        
        game.StarterGui:SetCore("SendNotification", {
            Title = "Teleporte Conclu√≠do!";
            Text = "Voc√™ foi teleportado para a posi√ß√£o salva.";
            Duration = 3;
        })
    else
        game.StarterGui:SetCore("SendNotification", {
            Title = "Erro!";
            Text = "Nenhuma posi√ß√£o foi salva ainda.";
            Duration = 3;
        })
    end
end

-- Mostrar barra de carregamento
ShowLoadingBar()

-- Criar interface Rayfield
local Window = Rayfield:CreateWindow({
    Name = "Sistema Avan√ßado de Movimenta√ß√£o",
    LoadingTitle = "Carregando Sistema...",
    LoadingSubtitle = "Por favor aguarde",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "MovementSystem",
        FileName = "Config"
    },
    Discord = {
        Enabled = false,
        Invite = "",
        RememberJoins = false
    },
    KeySystem = false
})

-- Tab Principal
local MainTab = Window:CreateTab("Main", 4483362458)

-- Toggle Float
local FloatToggle = MainTab:CreateToggle({
    Name = "Sistema de Flutua√ß√£o",
    CurrentValue = false,
    Flag = "FloatToggle",
    Callback = function(Value)
        if Value then
            FloatButton = CreateDraggableButton("Ativar Float", Color3.fromRGB(70, 70, 70), UDim2.new(0, 50, 0, 100), ToggleFloat)
        else
            if FloatEnabled then
                ToggleFloat() -- Desativar se estiver ativo
            end
            if FloatButton then
                FloatButton:Destroy()
                FloatButton = nil
            end
        end
    end
})

-- Toggle Chair System
local ChairToggle = MainTab:CreateToggle({
    Name = "Sistema de Cadeira M√≥vel",
    CurrentValue = false,
    Flag = "ChairToggle",
    Callback = function(Value)
        if Value then
            ChairButton = CreateDraggableButton("Ativar Cadeira", Color3.fromRGB(70, 70, 70), UDim2.new(0, 50, 0, 160), ToggleChairSystem)
        else
            if ChairSystemEnabled then
                ToggleChairSystem() -- Desativar se estiver ativo
            end
            if ChairButton then
                ChairButton:Destroy()
                ChairButton = nil
            end
        end
    end
})

-- Toggle NoClip System
local NoClipToggle = MainTab:CreateToggle({
    Name = "Sistema NoClip com Prote√ß√£o",
    CurrentValue = false,
    Flag = "NoClipToggle",
    Callback = function(Value)
        if Value then
            ToggleNoClip()
        else
            if NoClipEnabled then
                ToggleNoClip() -- Desativar se estiver ativo
            end
        end
    end
})
-- Toggle Position System
local PositionToggle = MainTab:CreateToggle({
    Name = "Sistema de Salvamento de Posi√ß√£o",
    CurrentValue = false,
    Flag = "PositionToggle",
    Callback = function(Value)
        if Value then
            SaveButton = CreateDraggableButton("Salvar Pos", Color3.fromRGB(100, 150, 100), UDim2.new(0, 50, 0, 220), SavePosition)
            TeleportButton = CreateDraggableButton("Teleportar", Color3.fromRGB(150, 100, 150), UDim2.new(0, 180, 0, 220), TeleportToSavedPosition)
        else
            if SaveButton then
                SaveButton:Destroy()
                SaveButton = nil
            end
            if TeleportButton then
                TeleportButton:Destroy()
                TeleportButton = nil
            end
        end
    end
})

-- Se√ß√£o de informa√ß√µes
MainTab:CreateSection("Informa√ß√µes do Sistema")

MainTab:CreateParagraph({
    Title = "Como usar:",
    Content = "1. Flutua√ß√£o: Ative o toggle e use o bot√£o que aparece\n2. Cadeira: Ative o toggle, segure os bot√µes para mover, use ‚ñ≤‚ñº para altura\n3. NoClip: Atravesse paredes com prote√ß√£o global anti-queda\n4. Posi√ß√µes: Salve e teleporte para posi√ß√µes espec√≠ficas"
})

-- Notifica√ß√£o de inicializa√ß√£o
Rayfield:Notify({
    Title = "Sistema Carregado!",
    Content = "Todos os recursos foram carregados com sucesso.",
    Duration = 5,
    Image = 4483362458
})

-- Limpeza ao sair
game.Players.PlayerRemoving:Connect(function(player)
    if player == LocalPlayer then
        -- Limpar todas as conex√µes e objetos
        if FloatConnection then FloatConnection:Disconnect() end
        if ChairConnection then ChairConnection:Disconnect() end
        if TeleportConnection then TeleportConnection:Disconnect() end
        if NoClipConnection then NoClipConnection:Disconnect() end
        
        -- Limpar conex√µes de movimento
        for i, connection in pairs(MovementConnections) do
            if connection then connection:Disconnect() end
        end
    end
end)
